



#### 1. HashMap
重点讲解：

- 初始容量为16，扩容为2n，装载因子为`0.75`，当容量大于16*0.75=12的时候进行扩容。
- 底层数据结构：基于哈希表的数据结构，用于存储键值对。 核心是将key的哈希值映射到数据索引位置，通过`数组+链表(Java8之后是数组+链表+红黑树)`来处理哈希冲突。当链表长度超过8时，链表将会转换为红黑树。树中的元素低于6时会转换回链表。

##### 1.1 常见问题

1. 为什么装载因子为0.75

   看这个https://javabetter.cn/collection/hashmap.html#_03%E3%80%81%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-0-75

   https://segmentfault.com/a/1190000023308658

   泊松分布大概意思感觉是为了解释为什么链表大于8的时候会转换为红黑树。

   **二项分布，提高空间利用率和 减少查询成本的折中**，0.75的话空间利用率比较高，降低hash冲突。

   `乘16可以最好一个整数。那么在0.5~1之间找一个小数，满足这要求的只有0.625（5/8），0.75（3/4），0.875（7/8）。这三个数让我选，从审美角度，还是从中位数角度，我都会挑0.75。毕竟碰撞是个概率问题，这个0.75我觉得不错，我没办法预知使用者的数据到底什么样子的，0.75是最为折中的一个选择。`

   泊松分布：单位时间内随机事件发生的次数的概率分布。

   `在C#中类似于Java的HashMap的类叫HashTable，它的负载因子是0.72,或许这个数字并没有那么简单吧。`

2. 为什么使用红黑树而不是B树或者平衡二叉树(AVL树)

   https://worktile.com/kb/ask/8990.html

   https://juejin.cn/post/6997969089717075975

   红黑树的英文是“Red-Black Tree”，简称R-B Tree，它是一种不严格的平衡二叉查找树。

​		红黑树是”近似平衡“的。

​		红黑树相比avl树，在检索的时候效率其实差不多，都是通过平衡来二分查找。但对于插入删除等操作效率提高很多。红黑树不像avl树一样追求绝对的平衡，他允许局部很少的不完全平衡，这样对于效率影响不大，但省去了很多没有必要的调平衡操作，avl树调平衡有时候代价较大，所以效率不如红黑树，在现在很多地方都是底层都是红黑树的天下啦。

所以，如果你的程序中，查询的次数远大于插入/删除，那么选择 AVL，如果查询，插入/删除的操作差不多，那应该选择 红黑树。

​		AVL树的应用场景：

​		windwos对进程地址空间的管理

​		红黑树的应用场景：

​		epoll在内核中的实现，用红黑树管理事件块（文件描述符）

​		Java的TreeMap实现

​		nginx中，用红黑树管理timer

​		linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块

3. HashMap的长度为什么是2的幂次方

   判断是否转为红黑树的关键代码：

   ```java
   final void treeifyBin(Node<K,V>[] tab, int hash) {
       int n, index; Node<K,V> e;
       // 判断当前数组的长度是否小于 64
       if (tab == null || (n = tab.length) < MIN_TREEIFY_CAPACITY)
           // 如果当前数组的长度小于 64，那么会选择先进行数组扩容
           resize();
       else if ((e = tab[index = (n - 1) & hash]) != null) {
           // 否则才将列表转换为红黑树
   
           TreeNode<K,V> hd = null, tl = null;
           do {
               TreeNode<K,V> p = replacementTreeNode(e, null);
               if (tl == null)
                   hd = p;
               else {
                   p.prev = tl;
                   tl.next = p;
               }
               tl = p;
           } while ((e = e.next) != null);
           if ((tab[index] = hd) != null)
               hd.treeify(tab);
       }
   }
   ```

   关键是里面的`(n - 1) & hash`

   运算中&比%高效。

   1. 位运算效率更高：当长度为 2 的幂次方时，hash % length 等价于 hash & (length - 1)。
   2. 可以更好地保证哈希值的均匀分布：扩容之后，在旧数组元素 hash 值比较均匀的情况下，新数组元素也会被分配的比较均匀，最好的情况是会有一半在新数组的前半部分，一半在新数组后半部分。
   3. 扩容机制变得简单和高效：扩容后只需检查哈希值高位的变化来决定元素的新位置，要么位置不变（高位为 0），要么就是移动到新位置（高位为 1，原索引位置+原容量）。

#### 2. HashTable

重点讲解

- 初始容量为11，扩容为2n+1

##### 2.1 常见问题

1. HashTable和HashMap有什么区别

   HashMap线程不安全，HashTable线程安全。
   
   Map的初始容量为16，扩容为2n。Table初始11，扩容2n+1。

#### 3. ConcurrentHashMap

##### 3.1 ConcurrentHashMap 在 1.7和1.8中有什么区别

JDK1.7 `ConcurrentHashMap `是采用的是分段锁，即每个 `segment `是独立的，可以并发访问不同的 `segment`，默认是16个 `segment `，所以最多有 16 个线程可以并发执行。

而JDK1.8移除了 `segment `，锁的粒度变得要加细化，锁只在链表或红黑树的**节点级别**上进行。通过CAS进行插入操作，只有在更新链表或红黑树时才使用 `synchronized`，并且只锁住链表或树的头节点，进一步减少了锁的竞争，并发度大大增加。

并且JDK1.7`ConcurrentHashMap`  只使用了数组+链表的结构，而JDK1.8和 `HashMap`一样引入了红黑树。

除此之外，还有扩容的区别以及 `size`方法的计算也不一样。



