



#### 1. HashMap
重点讲解：

- 初始容量为16，扩容为2n，装载因子为`0.75`，当容量大于16*0.75=12的时候进行扩容。

- 底层数据结构：基于哈希表的数据结构，用于存储键值对。 核心是将key的哈希值映射到数据索引位置，通过`数组+链表(Java8之后是数组+链表+红黑树)`来处理哈希冲突。当链表长度超过8时，链表将会转换为红黑树。树中的元素低于6时会转换回链表。
- 

##### 1.1 常见问题

1. 为什么装载因子为0.75

   看这个https://javabetter.cn/collection/hashmap.html#_03%E3%80%81%E5%8A%A0%E8%BD%BD%E5%9B%A0%E5%AD%90%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF-0-75

   https://segmentfault.com/a/1190000023308658

   泊松分布大概意思感觉是为了解释为什么链表大于8的时候会转换为红黑树。

   **提高空间利用率和 减少查询成本的折中**，0.75的话空间利用率比较高，降低hash冲突。

   `乘16可以最好一个整数。那么在0.5~1之间找一个小数，满足这要求的只有0.625（5/8），0.75（3/4），0.875（7/8）。这三个数让我选，从审美角度，还是从中位数角度，我都会挑0.75。毕竟碰撞是个概率问题，这个0.75我觉得不错，我没办法预知使用者的数据到底什么样子的，0.75是最为折中的一个选择。`

   泊松分布：单位时间内随机事件发生的次数的概率分布。

   `在C#中类似于Java的HashMap的类叫HashTable，它的负载因子是0.72,或许这个数字并没有那么简单吧。`

2. 为什么使用红黑树而不是B树或者平衡二叉树(AVL树)

   https://worktile.com/kb/ask/8990.html

   https://juejin.cn/post/6997969089717075975

   红黑树的英文是“Red-Black Tree”，简称R-B Tree，它是一种不严格的平衡二叉查找树。

​		红黑树是”近似平衡“的。

​		红黑树相比avl树，在检索的时候效率其实差不多，都是通过平衡来二分查找。但对于插入删除等操作效率提高很多。红黑树不像avl树一样追求绝对的平衡，他允许局部很少的不完全平衡，这样对于效率影响不大，但省去了很多没有必要的调平衡操作，avl树调平衡有时候代价较大，所以效率不如红黑树，在现在很多地方都是底层都是红黑树的天下啦。

所以，如果你的程序中，查询的次数远大于插入/删除，那么选择 AVL，如果查询，插入/删除的操作差不多，那应该选择 红黑树。

​		AVL树的应用场景：

​		windwos对进程地址空间的管理

​		红黑树的应用场景：

​		epoll在内核中的实现，用红黑树管理事件块（文件描述符）

​		Java的TreeMap实现

​		nginx中，用红黑树管理timer

​		linux进程调度Completely Fair Scheduler,用红黑树管理进程控制块

3. 

#### 2. HashTable

重点讲解

- 初始容量为11，扩容为2n+1

##### 2.1 常见问题

1. HashTable和HashMap有什么区别

   

